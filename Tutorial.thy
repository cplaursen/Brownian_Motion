(* Author: Christian Pardillo Laursen *)

theory Tutorial
  imports Brownian_Motion
begin

text \<open> In this document we cover all the background necessary to understand this development. I assume
  the reader is familiar with the Isabelle/HOL probability library, up to infinite product measures
  and the Kolmogorov extension theorem. For more details, consult @{cite holzlphd} for an overview
  of the probability theory, and @{cite immler12} for the Kolmogorov extension theorem.

  The reader is encouraged to explore the linked theories and lemmas for insights into the proof
  techniques used. \<close>

chapter \<open>Background theories\<close>

text \<open> As part of the development, we introduce some preliminaries required for our stochastic process
  definitions and properties. \<close>

section \<open>Convergence in measure\<close>

text \<open> We introduce two notions of convergence within a measure space: convergence in measure and
 convergence almost everywhere.\<close>

thm tendsto_measure_def

text \<open> Here, tendsto_measure M X l F states that a family X of random variables converges in
  measure M to limit l with mode of convergence given by filter F. If M is a probability space, we
  refer to this as convergence in probability.

  The set of finite measure A used  \<close>

section \<open>Stochastic processes\<close>

text \<open> The basic objects we work with are stochastic processes: families of random variables
 parameterised by an index set. We define them as a locale to obtain a predicate, which we then
 use to define the type of stochastic processes. \<close>

print_locale stochastic_process

typ "('t, 'a, 'b) stochastic_process"

text \<open> A stochastic process is a quadruple
   @{term "(M :: 'a measure, M' :: 'b measure, I :: 't set, X :: 't \<Rightarrow> 'a \<Rightarrow> 'b)"}
  such that M is a probability space and for all t, X t is @{term "M \<rightarrow>\<^sub>M M'"}' measurable. As is standard
  practice, we are using M' simply for the sigma algebra it carries, and ignoring the measure function.
  We define the following destructors (in order):
  @{term proc_source}, @{term proc_target}, @{term proc_index}, and @{term process}.

  We define constructor @{term "prob_space.process_of M M' I X \<omega>"}, where we supply a default
  value for the process to take outside its index set, and return a trivial process if X is not
  measurable within its index set. \<close>

text \<open> Stochastic processes are often analysed in terms of their "finite dimensional distributions":
  the joint distribution of the process at a finite number of indices. \<close>

thm distributions_def

text \<open> We show basic properties of the measure generated by the distributions in relation to the product
 measure, and prove that the distributions form a projective family, which gives us access to the Kolmogorov
 extension theorem: For any given stochastic process, there is an infinite product measure that agrees on
 all finite-dimensional distributions. \<close>

thm Stochastic_Process.emeasure_lim

text \<open> We reason about the increments of a process by using an ordered list of indices, and considering
 the increments they define. A process has independent increments if for any list of indices, the 
 corresponding increments are mutually indpendent. \<close>

thm indep_increments_def

text \<open> We could define stationary increments in an analogous way, but here it suffices to simply consider
 two indices: \<close>

thm stationary_increments_def

text \<open> To compare processes with each other, we first introduce the notion of compatibility: two processes
 are compatible if they have the same source, the same target sigma algebra, and the same
 index set\<close>

thm compatible_def

text \<open> A process X is a modification of process Y if they are compatible, and for each point t in their
  index set I, X t = Y t almost everywhere. If X and Y are modifications of each other and t is a point
  in their index set, then we can obtain a null set N such that @{term "\<forall>x \<in> space M - N. X t x = Y t x"}.
  Modification forms an equivalence relation - it is reflexive, transitive, symmetric. Moreover, modifications
  have identical distributions. \<close>

thm modification_def
thm modification_null_set
thm modification_imp_identical_distributions

text \<open> A stronger notion that modification is indistinguishability. Two processes X and Y are
  indistinguishable if there is a null set N such that @{term "\<forall>x \<in> space M - N. \<forall>t \<in> I. X t x = Y t x"}.
  Like modifications, it is an equivalence relation. \<close>

thm indistinguishable_def

text \<open> If two processes X and Y are indistinguishable, they are also modifications of each other. The
  two notions coincide when the index set is countable @{thm modification_countable}, since we can
  construct the null set required for them to be indistinguishable by taking the countable union over
  the null sets at each index point.

  We also show that modification implies indistinguishability if the index set is an interval and the
  processes are almost everywhere continuous @{thm modification_continuous_indistinguishable}. Because
  the functions are continuous, we can take the countable union over the null sets at rational points
  which approximate the irrational points arbitrarily closely.
\<close>

text \<open> In order to compare functions with different index sets, we define @{term restrict_index},
  which updates the index of a given process. \<close>

section \<open> Transition kernels \<close>

end